<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Search Widget Library Example</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .example-section {
            background: white;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .widget-container {
            border: 2px dashed #ddd;
            min-height: 200px;
            margin: 20px 0;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Special styling for search input container */
        #search-input-container {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
            min-height: 300px !important;
            height: 300px !important;
            border: none !important;
            border-radius: 12px !important;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1) !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }
        pre {
            background: #f8f8f8;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
        }
        .auto-mount-example {
            border: 2px solid #e3f2fd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Search Widget Library Examples</h1>
        
        <div class="example-section">
            <h2>Method 1: Auto-mount with data attribute</h2>
            <p>Simply add <code>data-search-widget</code> to any element:</p>
            <pre>&lt;div data-search-widget&gt;&lt;/div&gt;</pre>
            
            <div class="auto-mount-example" data-search-widget></div>
        </div>

        <div class="example-section">
            <h2>Method 2: Manual mounting with JavaScript</h2>
            <p>Use the JavaScript API to mount the widget programmatically:</p>
            <pre>
// Using the global SearchWidget object
SearchWidget.mount('#my-search-container');

// Or create a new instance
const widget = SearchWidget.createSearchWidget();
widget.mount('#my-search-container');
            </pre>
            
            <div id="manual-mount-container" class="widget-container"></div>
            <button onclick="mountWidget()">Mount Widget</button>
            <button onclick="unmountWidget()">Unmount Widget</button>
        </div>

        <div class="example-section">
            <h2>Method 3: Custom styling</h2>
            <p>You can apply custom CSS classes and styles:</p>
            <pre>
SearchWidget.mount('#styled-container', {
    className: 'my-custom-class',
    style: { 
        border: '2px solid #blue',
        borderRadius: '12px'
    }
});
            </pre>
            
            <div id="styled-container" class="widget-container"></div>
            <button onclick="mountStyledWidget()">Mount Styled Widget</button>
        </div>

        <div class="example-section">
            <h2>Method 4: Generic Component Mounting</h2>
            <p>Use the library's built-in mountComponent function to attach any component to a div:</p>
            <pre>
// Mount any component to any div using the library function
// The component will automatically fill the container and be centered
const searchWidget = SearchWidget.mountComponent('SearchInput', '#search-input-container', {
    placeholder: "Search",
    maxWidth: "500px",
    onSearch: (results) => console.log('Search results:', results),
    onLoadingChange: (loading) => console.log('Loading:', loading)
});

// The function returns an object with unmount and update methods
searchWidget.unmount(); // Remove the component
searchWidget.update({ placeholder: "New placeholder" }); // Update props

// Mount other components - they will fill their containers
const formWidget = SearchWidget.mountComponent('SearchForm', '#form-container', {
    // SearchForm props here
});

// Mount to any selector - component fills the target element
const widget = SearchWidget.mountComponent('SearchInput', '.my-search-div', {
    placeholder: "Search here"
});

// The component automatically:
// - Fills the container (width: 100%, height: 100%)
// - Centers content (flexbox centering)
// - Injects required CSS styles
// - Handles cleanup on unmount
            </pre>
            
            <div id="search-input-container" class="widget-container"></div>
            <button onclick="mountSearchInput()">Mount SearchInput Component</button>
            <button onclick="unmountSearchInput()">Unmount SearchInput</button>
            <button onclick="debugStyles()">Debug Styles</button>
            <button onclick="forceInjectCSS()">Force Inject CSS</button>
        </div>
    </div>

    <!-- Load the search widget library (standalone version with React bundled) -->
    <script src="./lib/search-widget.standalone.umd.js"></script>

    <script>
        let manualWidget = null;
        let searchInputWidget = null;

        // Check if SearchWidget is loaded
        function checkSearchWidgetLoaded() {
            if (typeof SearchWidget === 'undefined') {
                console.error('SearchWidget library failed to load from ./dist/lib/search-widget.standalone.umd.js');
                console.log('Available globals:', Object.keys(window).filter(key => key.includes('Search') || key.includes('React')));
                return false;
            }
            console.log('SearchWidget loaded successfully:', Object.keys(SearchWidget));
            return true;
        }

        // Check on page load
        window.addEventListener('load', function() {
            if (checkSearchWidgetLoaded()) {
                console.log('SearchWidget is ready to use');
                console.log('Available SearchWidget properties:', Object.keys(SearchWidget));
                
                // Check if CSS injection function is available
                if (SearchWidget._injectCSS) {
                    console.log('CSS injection function is available');
                    // Force inject CSS to ensure styles are loaded
                    SearchWidget._injectCSS();
                    console.log('CSS styles injected');
                } else {
                    console.error('CSS injection function not available');
                }
            } else {
                console.error('SearchWidget failed to load. Please check the script path and build the library.');
            }
        });

        function mountWidget() {
            if (typeof SearchWidget === 'undefined') {
                console.error('SearchWidget library not loaded');
                alert('SearchWidget library not loaded');
                return;
            }
            if (!manualWidget) {
                manualWidget = SearchWidget.createSearchWidget();
                manualWidget.mount('#manual-mount-container');
            }
        }

        function unmountWidget() {
            if (manualWidget) {
                manualWidget.unmount();
                manualWidget = null;
            }
        }

        function mountStyledWidget() {
            if (typeof SearchWidget === 'undefined') {
                console.error('SearchWidget library not loaded');
                alert('SearchWidget library not loaded');
                return;
            }
            SearchWidget.mount('#styled-container', {
                className: 'custom-search-widget',
                style: { 
                    border: '2px solid #2196F3',
                    borderRadius: '12px',
                    padding: '10px'
                }
            });
        }

        function mountSearchInput() {
            // Check if SearchWidget is available
            if (typeof SearchWidget === 'undefined') {
                console.error('SearchWidget library not loaded. Please ensure the script is loaded correctly.');
                alert('SearchWidget library not loaded. Please check the console for details.');
                return;
            }

            if (!searchInputWidget) {
                try {
                    console.log('Available SearchWidget methods:', Object.keys(SearchWidget));
                    
                    // Check if mountComponent is available
                    if (!SearchWidget.mountComponent) {
                        console.error('mountComponent function not available in SearchWidget');
                        alert('mountComponent function not available. Please rebuild the library.');
                        return;
                    }
                    
                    // Use the library's built-in mountComponent function
                    searchInputWidget = SearchWidget.mountComponent('SearchInput', '#search-input-container', {
                        placeholder: "Search",
                        maxWidth: "700px",
                        onSearch: (results) => {
                            console.log('Search results:', results);
                        },
                        onLoadingChange: (loading) => {
                            console.log('Loading:', loading);
                        }
                    });
                    console.log('SearchInput component mounted successfully');
                    
                    // Check if styles were injected
                    const styleElement = document.getElementById('search-widget-styles');
                    if (styleElement) {
                        console.log('✓ CSS styles found in DOM');
                    } else {
                        console.error('✗ CSS styles not found in DOM');
                    }
                } catch (error) {
                    console.error('Error mounting SearchInput:', error);
                    alert('Error mounting SearchInput: ' + error.message);
                }
            }
        }

        function unmountSearchInput() {
            if (searchInputWidget) {
                searchInputWidget.unmount();
                searchInputWidget = null;
                console.log('SearchInput component unmounted successfully');
            }
        }

        // Generic component mounting function
        function mountComponent(componentName, containerId, props = {}) {
            // Check if SearchWidget is available
            if (typeof SearchWidget === 'undefined') {
                console.error('SearchWidget library not loaded');
                return null;
            }

            const container = document.getElementById(containerId);
            if (!container) {
                console.error(`Container with id '${containerId}' not found`);
                return null;
            }

            container.innerHTML = ''; // Clear any existing content
            
            // Create a wrapper div for the component
            const wrapper = document.createElement('div');
            wrapper.className = 'search-widget-container';
            wrapper.style.display = 'flex';
            wrapper.style.justifyContent = 'center';
            wrapper.style.alignItems = 'center';
            wrapper.style.width = '100%';
            wrapper.style.padding = '20px';
            container.appendChild(wrapper);
            
            // Access React and ReactDOM from the SearchWidget global object
            const React = SearchWidget._React;
            const ReactDOM = SearchWidget._ReactDOM;
            
            if (React && ReactDOM) {
                // Always inject CSS styles to ensure they're available
                if (SearchWidget._injectCSS) {
                    SearchWidget._injectCSS();
                    console.log('CSS styles injected');
                }

                // Get the component from SearchWidget
                const Component = SearchWidget[componentName];
                if (!Component) {
                    console.error(`Component '${componentName}' not found in SearchWidget`);
                    return null;
                }
                
                // Render the component with provided props
                ReactDOM.render(
                    React.createElement(Component, props),
                    wrapper
                );
                
                return { container: wrapper, ReactDOM: ReactDOM };
            } else {
                console.error('React or ReactDOM not available in SearchWidget');
                return null;
            }
        }

        // Generic component unmounting function
        function unmountComponent(widget) {
            if (widget) {
                widget.ReactDOM.unmountComponentAtNode(widget.container);
                if (widget.container.parentNode) {
                    widget.container.parentNode.removeChild(widget.container);
                }
                return null;
            }
            return widget;
        }

        function debugStyles() {
            console.log('=== Style Debug Information ===');
            
            // Check if SearchWidget is loaded
            if (typeof SearchWidget === 'undefined') {
                console.error('SearchWidget not loaded');
                return;
            }
            
            // Check CSS injection function
            if (SearchWidget._injectCSS) {
                console.log('✓ CSS injection function available');
                SearchWidget._injectCSS();
                console.log('✓ CSS styles injected');
            } else {
                console.error('✗ CSS injection function not available');
            }
            
            // Check if styles are in DOM
            const styleElement = document.getElementById('search-widget-styles');
            if (styleElement) {
                console.log('✓ Style element found in DOM');
                console.log('Style content length:', styleElement.textContent.length);
                
                // Check for specific styles
                const styleContent = styleElement.textContent;
                const hasBorderStyle = styleContent.includes('border-[#6BD7FF]');
                const hasShadowStyle = styleContent.includes('shadow-lg');
                const hasRoundedStyle = styleContent.includes('rounded-lg');
                
                console.log('✓ Has border style:', hasBorderStyle);
                console.log('✓ Has shadow style:', hasShadowStyle);
                console.log('✓ Has rounded style:', hasRoundedStyle);
            } else {
                console.error('✗ Style element not found in DOM');
            }
            
            // Check container styling
            const container = document.getElementById('search-input-container');
            if (container) {
                console.log('✓ Container found');
                const computedStyle = window.getComputedStyle(container);
                console.log('Container background:', computedStyle.background);
                console.log('Container border:', computedStyle.border);
                console.log('Container border-radius:', computedStyle.borderRadius);
            } else {
                console.error('✗ Container not found');
            }
            
            console.log('=== End Debug Information ===');
        }

        function forceInjectCSS() {
            console.log('=== Force CSS Injection ===');
            
            if (typeof SearchWidget === 'undefined') {
                console.error('SearchWidget not loaded');
                return;
            }
            
            if (SearchWidget._injectCSS) {
                console.log('Calling _injectCSS...');
                SearchWidget._injectCSS();
                
                // Check if styles were injected
                const styleElement = document.getElementById('search-widget-styles');
                if (styleElement) {
                    console.log('✓ CSS styles injected successfully');
                    console.log('Style content length:', styleElement.textContent.length);
                    
                    // Check for specific styles
                    const styleContent = styleElement.textContent;
                    const hasBorderStyle = styleContent.includes('border-[#6BD7FF]');
                    const hasShadowStyle = styleContent.includes('shadow-lg');
                    const hasRoundedStyle = styleContent.includes('rounded-lg');
                    
                    console.log('✓ Has border style:', hasBorderStyle);
                    console.log('✓ Has shadow style:', hasShadowStyle);
                    console.log('✓ Has rounded style:', hasRoundedStyle);
                } else {
                    console.error('✗ CSS styles not found after injection');
                }
            } else {
                console.error('_injectCSS function not available');
            }
            
            console.log('=== End Force CSS Injection ===');
        }
    </script>
</body>
</html>
