<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Search Widget Library Example</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f5f5f5;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
      }
      .example-section {
        background: white;
        margin: 20px 0;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .widget-container {
        border: 2px dashed #ddd;
        min-height: 200px;
        margin: 20px 0;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      /* Special styling for search input container */
      #search-input-container {
        background: linear-gradient(
          135deg,
          #667eea 0%,
          #764ba2 100%
        ) !important;
        min-height: 300px !important;
        height: 300px !important;
        border: none !important;
        border-radius: 12px !important;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1) !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
      }
      pre {
        background: #f8f8f8;
        padding: 15px;
        border-radius: 4px;
        overflow-x: auto;
      }
      .auto-mount-example {
        border: 2px solid #e3f2fd;
        border-radius: 8px;
        padding: 20px;
        margin: 20px 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Search Widget Library Examples</h1>

      <div class="example-section">
        <h2>Method 1: Auto-mount with data attribute</h2>
        <p>Simply add <code>data-widget="search"</code> to any element:</p>
        <pre>&lt;div data-widget="search"&gt;&lt;/div&gt;</pre>

        <div class="auto-mount-example" data-widget="search"></div>
      </div>

      <div class="example-section">
        <h2>Method 2: Manual mounting with JavaScript</h2>
        <p>Use the JavaScript API to mount the widget programmatically:</p>
        <pre>
// Using the global SearchWidget object
SearchWidget.mount('#my-search-container');

// Or create a new instance
const widget = SearchWidget.createSearchWidget();
widget.mount('#my-search-container');
            </pre
        >

        <div id="manual-mount-container" class="widget-container"></div>
        <button onclick="mountWidget()">Mount Widget</button>
        <button onclick="unmountWidget()">Unmount Widget</button>
      </div>

      <div class="example-section">
        <h2>Method 3: Custom styling</h2>
        <p>You can apply custom CSS classes and styles:</p>
        <pre>
SearchWidget.mount('#styled-container', {
    className: 'my-custom-class',
    style: { 
        border: '2px solid #blue',
        borderRadius: '12px'
    }
});
            </pre
        >

        <div id="styled-container" class="widget-container"></div>
        <button onclick="mountStyledWidget()">Mount Styled Widget</button>
      </div>

      <div class="example-section">
        <h2>Method 4: Generic Component Mounting</h2>
        <p>
          Use the library's built-in mountComponent function to attach any
          component to a div:
        </p>
        <pre>
// Mount any component to any div using the library function
// The component will automatically fill the container and be centered
const searchWidget = SearchWidget.mountComponent('SearchInput', '#search-input-container', {
    placeholder: "Search",
    maxWidth: "500px",
    onSearch: (results) => console.log('Search results:', results),
    onLoadingChange: (loading) => console.log('Loading:', loading)
});

// The function returns an object with unmount and update methods
searchWidget.unmount(); // Remove the component
searchWidget.update({ placeholder: "New placeholder" }); // Update props

// Mount other components - they will fill their containers
const formWidget = SearchWidget.mountComponent('SearchForm', '#form-container', {
    // SearchForm props here
});

// Mount to any selector - component fills the target element
const widget = SearchWidget.mountComponent('SearchInput', '.my-search-div', {
    placeholder: "Search here"
});

// The component automatically:
// - Fills the container (width: 100%, height: 100%)
// - Centers content (flexbox centering)
// - Injects required CSS styles
// - Handles cleanup on unmount
            </pre
        >

        <div id="search-input-container" class="widget-container"></div>
        <button onclick="mountSearchInput()">
          Mount SearchInput Component
        </button>
        <button onclick="unmountSearchInput()">Unmount SearchInput</button>
        <button onclick="debugStyles()">Debug Styles</button>
        <button onclick="forceInjectCSS()">Force Inject CSS</button>
      </div>
    </div>

    <!-- Load the search widget library (standalone version with React bundled) -->
    <script src="./lib/search-widget.standalone.umd.js"></script>

    <script>
      let manualWidget = null;
      let searchInputWidget = null;

      // Check if SearchWidget is loaded
      function checkSearchWidgetLoaded() {
        if (typeof SearchWidget === "undefined") {
          console.error(
            "SearchWidget library failed to load from ./dist/lib/search-widget.standalone.umd.js"
          );
          console.log(
            "Available globals:",
            Object.keys(window).filter(
              (key) => key.includes("Search") || key.includes("React")
            )
          );
          return false;
        }
        console.log(
          "SearchWidget loaded successfully:",
          Object.keys(SearchWidget)
        );
        return true;
      }

      // Check on page load
      window.addEventListener("load", function () {
        if (checkSearchWidgetLoaded()) {
          console.log("SearchWidget is ready to use");
          console.log(
            "Available SearchWidget properties:",
            Object.keys(SearchWidget)
          );

          // Check if CSS injection function is available
          if (SearchWidget._injectCSS) {
            console.log("CSS injection function is available");
            // Force inject CSS to ensure styles are loaded
            SearchWidget._injectCSS();
            console.log("CSS styles injected");
          } else {
            console.error("CSS injection function not available");
          }
        } else {
          console.error(
            "SearchWidget failed to load. Please check the script path and build the library."
          );
        }
      });

      function mountWidget() {
        if (typeof SearchWidget === "undefined") {
          console.error("SearchWidget library not loaded");
          alert("SearchWidget library not loaded");
          return;
        }
        if (!manualWidget) {
          manualWidget = SearchWidget.createSearchWidget();
          manualWidget.mount("#manual-mount-container");
        }
      }

      function unmountWidget() {
        if (manualWidget) {
          manualWidget.unmount();
          manualWidget = null;
        }
      }

      function mountStyledWidget() {
        if (typeof SearchWidget === "undefined") {
          console.error("SearchWidget library not loaded");
          alert("SearchWidget library not loaded");
          return;
        }
        SearchWidget.mount("#styled-container", {
          className: "custom-search-widget",
          style: {
            border: "2px solid #2196F3",
            borderRadius: "12px",
            padding: "10px",
          },
        });
      }

      function mountSearchInput() {
        // Check if SearchWidget is available
        if (typeof SearchWidget === "undefined") {
          console.error(
            "SearchWidget library not loaded. Please ensure the script is loaded correctly."
          );
          alert(
            "SearchWidget library not loaded. Please check the console for details."
          );
          return;
        }

        if (!searchInputWidget) {
          try {
            console.log(
              "Available SearchWidget methods:",
              Object.keys(SearchWidget)
            );

            // Check if mountComponent is available
            if (!SearchWidget.mountComponent) {
              console.error(
                "mountComponent function not available in SearchWidget"
              );
              alert(
                "mountComponent function not available. Please rebuild the library."
              );
              return;
            }

            // Use the library's built-in mountComponent function
            searchInputWidget = SearchWidget.mountComponent(
              "SearchInput",
              "#search-input-container",
              {
                placeholder: "Search",
                maxWidth: "700px",
                onSearch: (results) => {
                  console.log("Search results:", results);
                },
                onLoadingChange: (loading) => {
                  console.log("Loading:", loading);
                },
              }
            );
            console.log("SearchInput component mounted successfully");

            // Check if styles were injected
            const styleElement = document.getElementById(
              "search-widget-styles"
            );
            if (styleElement) {
              console.log("✓ CSS styles found in DOM");
            } else {
              console.error("✗ CSS styles not found in DOM");
            }
          } catch (error) {
            console.error("Error mounting SearchInput:", error);
            alert("Error mounting SearchInput: " + error.message);
          }
        }
      }

      function unmountSearchInput() {
        if (searchInputWidget) {
          searchInputWidget.unmount();
          searchInputWidget = null;
          console.log("SearchInput component unmounted successfully");
        }
      }

      // Generic component mounting function
      function mountComponent(componentName, containerId, props = {}) {
        // Check if SearchWidget is available
        if (typeof SearchWidget === "undefined") {
          console.error("SearchWidget library not loaded");
          return null;
        }

        const container = document.getElementById(containerId);
        if (!container) {
          console.error(`Container with id '${containerId}' not found`);
          return null;
        }

        container.innerHTML = ""; // Clear any existing content

        // Create a wrapper div for the component
        const wrapper = document.createElement("div");
        wrapper.className = "search-widget-container";
        wrapper.style.display = "flex";
        wrapper.style.justifyContent = "center";
        wrapper.style.alignItems = "center";
        wrapper.style.width = "100%";
        wrapper.style.padding = "20px";
        container.appendChild(wrapper);

        // Access React and ReactDOM from the SearchWidget global object
        const React = SearchWidget._React;
        const ReactDOM = SearchWidget._ReactDOM;

        if (React && ReactDOM) {
          // Always inject CSS styles to ensure they're available
          if (SearchWidget._injectCSS) {
            SearchWidget._injectCSS();
            console.log("CSS styles injected");
          }

          // Get the component from SearchWidget
          const Component = SearchWidget[componentName];
          if (!Component) {
            console.error(
              `Component '${componentName}' not found in SearchWidget`
            );
            return null;
          }

          // Render the component with provided props
          ReactDOM.render(React.createElement(Component, props), wrapper);

          return { container: wrapper, ReactDOM: ReactDOM };
        } else {
          console.error("React or ReactDOM not available in SearchWidget");
          return null;
        }
      }

      // Generic component unmounting function
      function unmountComponent(widget) {
        if (widget) {
          widget.ReactDOM.unmountComponentAtNode(widget.container);
          if (widget.container.parentNode) {
            widget.container.parentNode.removeChild(widget.container);
          }
          return null;
        }
        return widget;
      }

      function debugStyles() {
        console.log("=== Style Debug Information ===");

        // Check if SearchWidget is loaded
        if (typeof SearchWidget === "undefined") {
          console.error("SearchWidget not loaded");
          return;
        }

        // Check CSS injection function
        if (SearchWidget._injectCSS) {
          console.log("✓ CSS injection function available");
          SearchWidget._injectCSS();
          console.log("✓ CSS styles injected");
        } else {
          console.error("✗ CSS injection function not available");
        }

        // Check if styles are in DOM
        const styleElement = document.getElementById("search-widget-styles");
        if (styleElement) {
          console.log("✓ Style element found in DOM");
          console.log("Style content length:", styleElement.textContent.length);

          // Check for specific styles
          const styleContent = styleElement.textContent;
          const hasBorderStyle = styleContent.includes("border-[#6BD7FF]");
          const hasShadowStyle = styleContent.includes("shadow-lg");
          const hasRoundedStyle = styleContent.includes("rounded-lg");

          console.log("✓ Has border style:", hasBorderStyle);
          console.log("✓ Has shadow style:", hasShadowStyle);
          console.log("✓ Has rounded style:", hasRoundedStyle);
        } else {
          console.error("✗ Style element not found in DOM");
        }

        // Check container styling
        const container = document.getElementById("search-input-container");
        if (container) {
          console.log("✓ Container found");
          const computedStyle = window.getComputedStyle(container);
          console.log("Container background:", computedStyle.background);
          console.log("Container border:", computedStyle.border);
          console.log("Container border-radius:", computedStyle.borderRadius);
        } else {
          console.error("✗ Container not found");
        }

        console.log("=== End Debug Information ===");
      }

      function forceInjectCSS() {
        console.log("=== Force CSS Injection ===");

        if (typeof SearchWidget === "undefined") {
          console.error("SearchWidget not loaded");
          return;
        }

        if (SearchWidget._injectCSS) {
          console.log("Calling _injectCSS...");
          SearchWidget._injectCSS();

          // Check if styles were injected
          const styleElement = document.getElementById("search-widget-styles");
          if (styleElement) {
            console.log("✓ CSS styles injected successfully");
            console.log(
              "Style content length:",
              styleElement.textContent.length
            );

            // Check for specific styles
            const styleContent = styleElement.textContent;
            const hasBorderStyle = styleContent.includes("border-[#6BD7FF]");
            const hasShadowStyle = styleContent.includes("shadow-lg");
            const hasRoundedStyle = styleContent.includes("rounded-lg");

            console.log("✓ Has border style:", hasBorderStyle);
            console.log("✓ Has shadow style:", hasShadowStyle);
            console.log("✓ Has rounded style:", hasRoundedStyle);
          } else {
            console.error("✗ CSS styles not found after injection");
          }
        } else {
          console.error("_injectCSS function not available");
        }

        console.log("=== End Force CSS Injection ===");
      }
    </script>
  </body>
</html>
