name: Build and Deploy to Production

on:
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

concurrency:
  group: deploy-${{ github.ref_name }}
  cancel-in-progress: true

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Validate branch pattern
        run: |
          BRANCH="${{ github.ref_name }}"
          if [[ "$BRANCH" != "main" && "$BRANCH" != release/* ]]; then
            echo "Only 'main' or 'release/*' branches are allowed for production deployments"
            echo "Current branch: $BRANCH"
            exit 1
          fi
          echo "✓ Branch validation passed: $BRANCH"

  build:
    runs-on: ubuntu-latest
    needs: validate
    timeout-minutes: 20
    environment: 'production'
    outputs:
      target_sha: ${{ steps.rev.outputs.sha }}
    steps:
      - name: Checkout selected branch
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        id: configure-aws-credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: eu-central-1
          role-to-assume: ${{ vars.AWS_ROLE_TO_ASSUME }}

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Read version from package.json
        id: pkg
        run: node -e "require('fs').appendFileSync(process.env.GITHUB_OUTPUT, 'version=' + require('./package.json').version + '\n')"

      - name: Install dependencies
        run: yarn install --frozen-lockfile
      - name: Build static web (Vite)
        env:
          CI: ''
        run: |
          mv .env.example .env
          bash tenant/build.sh

      - name: Resolve target SHA
        id: rev
        run: echo "sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT

      - name: "Notify Slack: Deployment started"
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_HOOK_URL }}
          BRANCH: ${{ github.ref_name }}
          REPO: ${{ github.repository }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          VERSION: ${{ steps.pkg.outputs.version }}
          SHA: ${{ steps.rev.outputs.sha }}
          ACTOR: ${{ github.actor }}
        run: |
          curl -X POST -H 'Content-type: application/json' --data "{\"text\":\"*Shopify Dummy Shop deploy started* :rocket:\nRepo: ${REPO}\nBranch: ${BRANCH}\nVersion: ${VERSION}\nSHA: ${SHA}\nBy: ${ACTOR}\nRun: ${RUN_URL}\"}" "$SLACK_WEBHOOK_URL"

      - name: Store the build in s3
        run: |
          aws s3 sync --delete ./dist s3://${{ vars.BUILD_BUCKET }}/shopify-dummy-shop/build/${{ steps.rev.outputs.sha }}
          aws s3 sync --delete ./dist s3://${{ vars.BUILD_BUCKET }}/shopify-dummy-shop/build/production

  deploy:
    runs-on: ubuntu-latest
    needs: build
    timeout-minutes: 20
    environment: 'production'
    steps:
      - name: Checkout selected branch
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        id: configure-aws-credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: eu-central-1
          role-to-assume: ${{ vars.AWS_ROLE_TO_ASSUME }}

      - name: Download the build
        env:
          CI: ''
        run: |
          mkdir build
          aws s3 sync s3://${{ vars.BUILD_BUCKET }}/shopify-dummy-shop/build/${{ needs.build.outputs.target_sha }} ./build
          
          echo "Downloading environment file from: ${{ vars.ENV_FILE_URL }}"
          aws s3 cp "${{ vars.ENV_FILE_URL }}" .env || {
            echo "Error: Failed to download .env file from S3"
            echo "Expected location: ${{ vars.ENV_FILE_URL }}"
            exit 1
          }
          
          echo "Environment file downloaded. Contents:"
          cat .env | grep -v -E '^[[:space:]]*#' | grep -v '^[[:space:]]*$' || echo "(empty or no variables)"
          
          # Create TENANT_INJECT_* variables from all variables in .env for inject.sh
          # Use a safer method that handles values with spaces
          echo "Creating TENANT_INJECT_* variables for tenant injection..."
          while IFS= read -r line || [ -n "$line" ]; do
            # Skip comments and empty lines
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "$line" ]] && continue
            [[ ! "$line" =~ = ]] && continue
            
            # Split on first '=' to handle values with '=' in them
            var_name="${line%%=*}"
            var_value="${line#*=}"
            
            # Remove leading/trailing whitespace from variable name
            var_name=$(echo "$var_name" | xargs)
            
            # Remove quotes from value if present, but preserve spaces
            var_value=$(echo "$var_value" | sed -e 's/^["'\'']//' -e 's/["'\'']$//')
            
            # Export the original variable
            export "${var_name}=${var_value}"
            
            # Create TENANT_INJECT_ version for inject.sh
            export "TENANT_INJECT_${var_name}=${var_value}"
            echo "✓ Created TENANT_INJECT_${var_name}=${var_value:0:20}..." # Show first 20 chars for verification
          done < .env
          
          # Verify key variables were created
          echo ""
          echo "Verifying TENANT_INJECT_ variables:"
          env | grep "^TENANT_INJECT_VITE_" | sed 's/=.*/=***/' || echo "No TENANT_INJECT_VITE_* variables found!"
          
          echo ""
          echo "Running tenant injection script..."
          bash tenant/inject.sh build
          
          # Verify injection worked by checking a built file
          echo ""
          echo "Verifying injection results in built files:"
          if [ -f "build/assets/index-*.js" ]; then
            built_file=$(ls build/assets/index-*.js | head -1)
            if grep -q "TENANT_INJECT_VITE_INOPS_SEARCH_KEY" "$built_file"; then
              echo "⚠️  WARNING: Placeholders still found in $built_file - injection may have failed"
            else
              echo "✓ Placeholders replaced in built files"
              # Check if actual values are present (masked for security)
              if grep -q "_4a2VpKF0ljmqLTKmyUuzvgq6ya3Q41VNbO9UkhH" "$built_file"; then
                echo "✓ SearchKey value found in built file"
              fi
            fi
          else
            echo "Could not find built JS file to verify injection"
          fi
      - name: Deploy
        uses: reggionick/s3-deploy@v4
        with:
          folder: build
          bucket: ${{ vars.S3_BUCKET }}
          bucket-region: ${{ vars.S3_BUCKET_REGION }}
          dist-id: ${{ vars.CLOUDFRONT_DISTRIBUTION_ID }}
          invalidation: /
          delete-removed: true
          no-cache: true
          private: true
          files-to-include: '{.*/**,**}'

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Configure CloudFront Domain Alias
        run: |
          DIST_ID="${{ vars.CLOUDFRONT_DISTRIBUTION_ID }}"
          DOMAIN="shopify-dummy.inops.io"
          
          echo "Checking CloudFront distribution: $DIST_ID"
          
          # Get current distribution config
          aws cloudfront get-distribution-config --id "$DIST_ID" > /tmp/dist-config.json || {
            echo "Error: Failed to get CloudFront distribution config. Check DIST_ID and permissions."
            exit 1
          }
          
          # Extract ETag and config
          ETAG=$(jq -r '.ETag' /tmp/dist-config.json)
          CONFIG=$(jq -r '.DistributionConfig' /tmp/dist-config.json)
          
          # Get current aliases (handle both Items array and empty/null)
          CURRENT_ALIASES=$(echo "$CONFIG" | jq -r '.Aliases.Items // [] | join(",")')
          echo "Current aliases: ${CURRENT_ALIASES:-none}"
          
          # Check if domain already exists in aliases
          DOMAIN_EXISTS=$(echo "$CONFIG" | jq -r ".Aliases.Items // [] | any(. == \"$DOMAIN\")")
          
          if [ "$DOMAIN_EXISTS" = "true" ]; then
            echo "✓ Domain alias already configured: $DOMAIN"
          else
            echo "Adding domain alias: $DOMAIN"
            
            # Get existing aliases or initialize empty array
            EXISTING_ALIASES=$(echo "$CONFIG" | jq -r '.Aliases.Items // []')
            
            # Add domain to aliases
            UPDATED_CONFIG=$(echo "$CONFIG" | jq --arg domain "$DOMAIN" \
              '.Aliases.Items = (.Aliases.Items // []) + [$domain] | .Aliases.Quantity = (.Aliases.Items | length)')
            
            # Update distribution
            echo "$UPDATED_CONFIG" > /tmp/updated-config.json
            aws cloudfront update-distribution \
              --id "$DIST_ID" \
              --if-match "$ETAG" \
              --distribution-config file:///tmp/updated-config.json || {
              echo "Warning: Failed to update CloudFront distribution. You may need to add the domain alias manually."
            }
            
            echo "✓ Domain alias added. Note: Distribution update takes ~15 minutes to propagate."
          fi
          
          # Verify SSL certificate exists for domain
          echo ""
          echo "Checking SSL certificate status..."
          CERT_CHECK=$(aws acm list-certificates --region us-east-1 --query "CertificateSummaryList[?DomainName=='$DOMAIN' || DomainName=='*.inops.io'].{Domain:DomainName,Status:Status}" --output table 2>&1)
          if [ $? -eq 0 ]; then
            echo "$CERT_CHECK"
          else
            echo "Note: Could not check ACM certificates. Ensure SSL certificate for $DOMAIN exists in us-east-1 region."
          fi
          
          # Get CloudFront domain name
          CF_DOMAIN=$(echo "$CONFIG" | jq -r '.DomainName')
          echo ""
          echo "=========================================="
          echo "DNS Configuration Required"
          echo "=========================================="
          echo "Create a CNAME record in your DNS provider:"
          echo "  Name: shopify-dummy"
          echo "  Value: $CF_DOMAIN"
          echo ""
          echo "Or use Route53 A record (alias) pointing to CloudFront distribution: $DIST_ID"
          echo "=========================================="

      - name: "Notify Slack: Deployment succeeded"
        if: success()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_HOOK_URL }}
          BRANCH: ${{ github.ref_name }}
          REPO: ${{ github.repository }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          VERSION: ${{ needs.build.outputs.target_sha }}
          BUCKET: ${{ vars.S3_BUCKET }}
          DIST_ID: ${{ vars.CLOUDFRONT_DISTRIBUTION_ID }}
        run: |
          curl -X POST -H 'Content-type: application/json' --data "{\"text\":\"*Shopify Dummy Shop deploy succeeded* :white_check_mark:\nRepo: ${REPO}\nBranch: ${BRANCH}\nBuild: ${VERSION}\nBucket: ${BUCKET}\nCF Dist: ${DIST_ID}\nRun: ${RUN_URL}\"}" "$SLACK_WEBHOOK_URL"

      - name: "Notify Slack: Deployment failed"
        if: failure()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_HOOK_URL }}
          BRANCH: ${{ github.ref_name }}
          REPO: ${{ github.repository }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          VERSION: ${{ needs.build.outputs.target_sha }}
          BUCKET: ${{ vars.S3_BUCKET }}
          DIST_ID: ${{ vars.CLOUDFRONT_DISTRIBUTION_ID }}
        run: |
          curl -X POST -H 'Content-type: application/json' --data "{\"text\":\"*Shopify Dummy Shop deploy failed* :x:\nRepo: ${REPO}\nBranch: ${BRANCH}\nBuild: ${VERSION}\nBucket: ${BUCKET}\nCF Dist: ${DIST_ID}\nRun: ${RUN_URL}\"}" "$SLACK_WEBHOOK_URL"


